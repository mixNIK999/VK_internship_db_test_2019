# Сборка
Для сборки клонируйте репозиторий, перейдите в папку и выполните `make` (Собираеться довольно долго!).
После сборки появится папка `out/` в которой лежит исполняемый файл.
Его можно запустить без дополнительных параметров, чтобы выполнились тесты (Может занять много времени на слабом железе!).

# Описание
Мой алгоритм представляет собой два алгоритма и выбор из них:
1. Решение через хеш-таблицу
2. Простой алгоритм, который для каждого элемента одного массива за линию сравнивает его со всеми элементами второго.

Обозначим размеры массивов через m и n. Решение через хеш-таблицу работает за O(n + m), но имеет большую константу, поэтому для случаев с min(m, n) < min_const используем простой алгоритм за O(nm) с очень маленькой константой. min_const подбираем с помощью случайных тестов.

Также была идея сортировать маленький массив, а затем для каждого элемента большого массива искать его с помощью бинпоиска. Суммарно получаем O((n + m) log n), но на практике оказалось, что это не выгодно.

Еще можно взять другую структуру данных вместо хеш-таблицы, например деревья, но они все в данном случае проигрывают сортировке массива + бинпоиск.
